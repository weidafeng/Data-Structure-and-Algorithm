# -*- coding: utf-8 -*-#
#-------------------------------------------------------------------------------
# Name:         最大公约数.py
# Author:       wdf
# Date:         11/28/2019
# IDE：         PyCharm 
# Parameters:
#     @param:
#     @param:
# Return： 
#       
# Description:  
# Usage：
#-------------------------------------------------------------------------------
# 方法一，辗转相除法/欧几里得法
#  两个正整数a和b（a>b） ， 它们的最大公约数
# 等于a除以b的余数c和b之间的最大公约数。
# 例如10和25， 25除以10商2余5， 那么10和25的最大公约数， 等同于10和5的最大公约数

# 可以使用递归的方法把问题逐步简化。
# 首先， 计算出a除以b的余数c， 把问题转化成求b和c的最大公约数； 然
# 后计算出b除以c的余数d， 把问题转化成求c和d的最大公约数； 再计算
# 出c除以d的余数e， 把问题转化成求d和e的最大公约数……以此类推， 逐渐把两个较大整数之间的运算简化成两个较小整数之间的
# 运算， 直到两个数可以整除， 或者其中一个数减小到1为止。

def gcd_euclidean(a, b):
    big, small = max(a,b), min(a, b)

    if big % small == 0:
        return small

    return gcd_euclidean(big % small, small)


# 方法二，更相减损法
# 辗转相除法有一个问题， 当两个整数较大时， 做a%b取模运算的性能会比较差。
# 两个正整数a和b（a>b） ， 它们的最大公约数等于
# a-b的差值c和较小数b的最大公约数。 例如10和25， 25减10的差是15，
# 那么10和25的最大公约数， 等同于10和15的最大公约数。
#
# 同样可以通过递归来简化问题。 首先， 计算出a和b的差值
# c（假设a>b） ， 把问题转化成求b和c的最大公约数； 然后计算出c和b的
# 差值d（假设c>b） ， 把问题转化成求b和d的最大公约数； 再计算出b和d
# 的差值e（假设b>d） ， 把问题转化成求d和e的最大公约数……
# 以此类推， 逐渐把两个较大整数之间的运算简化成两个较小整数之间的
# 运算， 直到两个数可以相等为止， 最大公约数就是最终相等的这两个数
# 的值

# 更相减损术依靠两数求差的方式来递归， 运算次数肯定远大于辗转相除法的取模方式吧？

def gcd_chinese(a, b):
    big, small = max(a,b), min(a, b)
    if big - small == 0:
        return small

    return gcd_chinese(big-small, small)

def main():
    print(gcd_euclidean(10,5))
    print(gcd_chinese(10,5))


if __name__ == '__main__':
    main()